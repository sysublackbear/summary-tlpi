### Chapter22.信号：高级特性

#### 1.核心转储文件（core文件）

特定信号会引发进程创建一个核心转储文件并终止运行。所谓核心转储是内含进程终止是内存映像的一个文件。将该内存映像加载到调试器中，即可查明信号到达时程序代码和数据的状态。

引发程序生成核心转储文件的方式之一是键入退出字符（通常是ctrl-\），从而生成SIGQUIT信号。



#### 2.传递，处置及处理的特殊情况

##### SIGKILL 和 SIGSTOP

**SIGKILL**信号的默认行为是终止一个进程，**SIGSTOP**信号的默认行为是停止一个进程，两者的默认行为均无法改变。当试图用signal()和sigaction()来改变对这些信号的处置时，将总是返回错误。同样，也不能将这两个信号阻塞。这是一个深思熟虑的设计决定。不允许修改这些信号的默认行为，这也意味着总是可以利用这些信号来杀死或者停止一个失控进程。

##### SIGCONT 和停止信号

如前所述，可使用SIGCONT 信号来使某些（因接收 SIGSTOP，SIGTSTP，SIGTTIN 和 SIGTTOUT 信号）处于停止状态的进程得以继续运行。由于这些停止信号具有独特目的，所以在某些情况下内核对它们的处理方式将有别于其他信号。



#### 3.可中断和不可中断的进程睡眠状态

内核经常需要令进程进入休眠，而休眠状态又分为两种。

+ **TASK_INTERRUPTIBLE**：进程正在等待某一事件。例如，正在等待终端输入，等待数据写入当前的空管道，或者等待System V 信号量值的增加。进程在该状态下所耗费的时间可长可短。如果为这种状态下的进程产生一个信号，那么操作将中断，而传递来的信号将唤醒进程。
+ **TASK_UNINTERRUPTIBLE**：进程正在等待某些特定类型的事件，比如磁盘I/O的完成。如果为这种状态下的进程产生一个信号，那么在进程摆脱这种状态之前，系统将不会把信号传递给进程。



#### 4.硬件产生的信号

硬件异常可以产生SIGBUS，SIGFPE，SIGILL和SIGSEGV信号。

正确处理硬件产生信号的方法有二：要么接受信号的默认行为（进程终止）；要么为其编写不会正常返回的处理器函数。除了正常返回之外，终结处理器执行的手段还包括调用_exit()以终止进程，或者调用siglongjmp()，确保将控制传递回程序中的某一位置。



#### 5.信号传递的时机与顺序

##### 何时传递一个信号？

只有在以下时刻才会传递信号：

+ 进程在前度超时后，再度获得调度时（即，在一个时间片的开始处）；
+ 系统调用完成时（信号的传递可能引起正在阻塞的系统调用过早完成）。



##### 解除对多个信号的阻塞时，信号的传递顺序

就目前的Linux实现而言，Linux内核按照信号编号的升序来传递信号。



#### 6.解除信号阻塞和挂起进程这两个动作的原子性操作：sigsuspend()

```c++
#include <signal.h>

int sigsuspend(const sigset_t * mask);
```



#### 7.实时信号

- 实时信号的信号范围有所扩大，可应用于应用程序自定义的目的。
- 对实时信号所采取的是队列化管理。如果将某一实时信号的多个实例发送给一进程，那么将会多次传递信号。相反，如果某一标准信号已经在等待某一进程，而此时即使再次向该进程发送此信号的实例，信号也只会传递一次。
- 当发送一个实时信号时，可为信号指定伴随数据，供接收进程的信号处理器函数。
- 不同实时信号的传递顺序得到保障。如果有多个不同的实时信号处于等待状态，那么将率先传递具有最小编号的信号。

#### 8.发送实时信号

系统调用 sigqueue() 将由 sig 指定的实时信号发送给由 pid 指定的进程。

```c++
#define _POSIX_C_SOURCE 199309
#include <signal.h>

int sigqueue(pid_t pid, int sig, const union sigval value);
```



#### 9.以同步方式等待信号

可利用sigwaitinfo() 系统调用来同步接收信号。

```c++
#define _POSIX_C_SOURCE 199309
#include <signal.h>

int sigwaitinfo(const sigset_t *set, siginfo_t *info);
```



#### 10.通过文件描述符来获取信号

Linux提供了signalfd()系统调用：利用该调用可以创建一个特殊文件描述符，发往调用者的信号都可从该描述符中读取。signalfd机制为同步接收信号提供了sigwaitinfo()之外的另一种选择。

```c++
#include <sys/signalfd.h>

int sinalfd(int fd, const sigset_t *mask, int flags);
```



#### 11.利用信号进行进程间通信的弊端

从某种角度，可将信号视为进程间通信（IPC）的方式之一。然而，信号作为一种IPC机制却也饱受限制。首先，与后续各章描述的其他IPC方法相比，对信号编程既繁且难，具体原因如下：

- 信号的异步本质就意味着需要面对各种问题，包括可重入性需求，竞态条件及在信号处理器中正确处理全局变量。（如果用sigwaitinfo() 或者 signalfd() 来同步获取信号，这些问题中的大部分都不会遇到）。
- 没有对标准信号进行排队处理。即使是对于实时信号，也存在对信号排队数量的限制。这意味着，为了避免丢失信息，接收信号的进程必须想方设法通知发送者，自己为接受另一个信号做好了准备。要做到这一点，最显而易见的方法是由接收者向发送者发送信号。

还有一个更深层次的问题，信号所携带的信息量有限：信号编号以及实时信号情况下一字之长的附加数据（一个整数或者一枚指针值）。与诸如管道之类的其他IPC方法相比，过低的带宽使得信号传输极为缓慢。

由于上述种种限制，很少将信号用于IPC。



