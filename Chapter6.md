### Chapter6.进程

#### 1.进程和程序

进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。

从内核角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs），虚拟内存表，打开文件的描述符表，信号传递及处理的有关信息，进程资源使用及限制，当前工作目录和大量的其他信息。



#### 2.获取进程号和父进程号

```c++
#include <unistd.h>

pid_t getpid(void);

pid_t getppid(void);
```



#### 3.虚拟内存管理

Linux，像多数现代内核一样，采用了虚拟内存管理技术。

虚拟内存的规划之一是将每个程序使用的内存切割小型的，固定大小的“页”单元。相应地，将RAM划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集。程序未使用的页拷贝保存在交换区内——这是磁盘空间中的保留区域，作为计算机RAM的补充——仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误，内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。



#### 4.环境列表

新进程在创建之时，会继承其父进程的环境副本。这是一种原始的进程间通信方式，却颇为常用。环境提供了将信息从父进程传递给子进程的方法。由于子进程只有在创建时才能获得其父进程的环境副本，所以这一信息传递是单向的，一次性的。子进程创建后，父，子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。



相关方法：

```c++
#include <stdlib.h>

char * getenv(const char * name);

int putenv(char * string);

int setenv(const char * name, const char * value, int overwrite);

int unsetenv(const char * name);

int clearenv(void);
```



#### 5.执行非局部跳转：setjmp() 和 longjmp()

```c++
#include <setjmp.h>

int setjmp(jmp_buf env);

void longjmp(jmp_buf env, int val);
```

