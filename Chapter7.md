### Chapter7.内存分配

#### 1.在堆上分配内存

方式一：调整program break：brk() 和 sbrk()

```c++
#include <unistd.h>

int brk(void * end_data_segment);

void *sbrk(intptr_t increment);
```

方式二：在堆上分配内存：malloc() 和 free()，具备的优点在于：

+ 属于C语言标准的一部分；
+ 更易于在多线程程序中使用；
+ 接口简单，允许分配小块内存；
+ 允许随意释放内存块，它们被维护于一张空闲内存列表中，在后续内存分配调用时循环使用。

```c++
#include <stdlib.h>

void * malloc(size_t size);

void free(void *ptr);
```



#### 2.调用free()还是不调用free()

当进程终止时，其占用的所有内存都会返还给操作系统，这包括在堆内存中由malloc 函数包内一系列函数所分配的内存。基于内存的这一自动释放机制，对于那些分配了内存并在进程终止前持续使用的程序而言，通常会省略对free的调用。这在程序中分配了多块内存的情况下可能会特别有用，因为加入多次对free() 的调用不但会消耗大量的CPU时间，而且可能会使代码趋于复杂。

虽然依靠终止进程来自动释放内存对大多数程序来说是可以接受的，但基于以下几个原因，最好能够在程序中显式释放所有的已分配内存。

+ 显式调用free() 能使程序在未来修改时更具可读性和可维护性。
+ 如果使用malloc调试库来查找程序的内存泄露问题，那么会将任何未经显式释放处理的内存报告为内存泄露，这会使发现真正内存泄露的工作复杂化。




#### 3.malloc和free在使用时应该注意的

+ 分配一块内存后，应当小心谨慎，不要改变这块内存范围外的任何内容。错误的指针运算，或者循环更新内存块内容时出现的“off-by-one"错误，都有可能导致这一情况。
+ 释放同一块已分配内存超过一次是错误的。Linux上的glibc库经常报出分段错误（SIGSEGV信号）。这是好事，因为它提醒我们犯下了一个编程错误。然而，当两次释放同一块内存时，更常见的后果是导致不可预知的行为。
+ 若非经由malloc函数包中函数所返回的指针，绝不能在调用free函数时使用。
+ 在编写需要长时间运行的程序（例如，shell或网络守护进程）时，出于各种目的，如果需要反复分配内存，那么应当确保释放所有已使用完毕的内存。如若不然，堆将稳步增长，直至抵达可用虚拟内存的上限，在此之后分配内存的任何尝试都将以失败告终，这种情况被称之为”内存泄露“。



#### 4.在堆上分配内存的其他方法

函数calloc()用于给一组相同对象分配内存。

```c++
#include <stdlib.h>

void *calloc(size_t numitems, size_t size);
```

realloc()函数用来调整（通常是增加）一块内存的大小，而此块内存应是之前由malloc包中函数所分配的。

```c++
#include <stdlib.h>

void *realloc(void * ptr, size_t size);
```



#### 5.在堆栈上分配内存：alloca()

和malloc函数包中的函数功能一样，alloca()也可以动态分配内存，不过不是从堆上分配内存，而是通过增加栈帧的大小从堆栈上分配。根据定义，当前调用函数的栈帧位于堆栈的顶部，故而这种方法是可行的。因此，帧的上方存在扩展空间，只需修改堆栈指针值即可。

```c++
#include <alloca.h>

void *alloca(size_t size);
```

使用alloca()来分配内存相对于malloc()有一定优势。其中之一是，alloca()分配内存的速度要快于malloc()，因为编译器将alloca()作为内联代码处理，并通过直接调整堆栈指针来实现。此外，alloca()也不需要维护空闲内存块列表。

另一个优点在于，由alloca()分配的内存随栈帧的移除而自动释放，亦即当调用alloca的函数返回之时。之所以如此，是因为函数返回时所执行的代码会重置栈指针寄存器，使其指向前一帧的末尾（即，假设堆栈向下增长，则指向恰好位于当前栈帧起始处之上的地址）。由于在函数的所有返回路径中都无需确保去释放所有的已分配内存，一些函数的编码也变得简单很多。

