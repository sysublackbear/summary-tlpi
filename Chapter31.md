### Chapter31.线程：线程安全和每线程存储

#### 1.实现线程安全的方法

+ 其一是将函数与互斥量关联使用（如果函数库中的所有函数都共享同样的全局变量，那么或许应将所有函数都与该互斥量相关联），在调用函数时将其锁定，在函数返回时解锁。这一方法的优点在于简单。另一方面，这也意味着同时只能有一个线程执行该函数，亦即，对该函数的访问是串行的。如果各线程在执行此函数时都耗费了相当多的时间，那么串行化会导致并发能力的丧失，所有线程将不再并发执行。
+ 另一种更为复杂的解决方案是，将共享变量与互斥量关联起来。这需要程序员们确认函数的哪些部分是使用了共享变量的临界区，且仅在执行到临界区时去获取和释放互斥量。这将允许多线程同时执行一个函数并实现并行，除非出现多个线程需要同时执行同一临界区的情况。

#### 2.可重入和不可重入函数

较之于对整个函数使用互斥量，使用临界区实现线程安全虽然有明显改进，但由于存在对互斥量的加锁和解锁开销，所以多少还是有些低效。可重入函数则无需使用互斥量即可实现线程安全。其要诀在于避免对全局和静态变量的使用。需要返回给调用者的任何信息，亦或是需要在对函数历次调用间加以维护的信息，都存储于由调用者分配的缓冲区内。不过，并非所有函数都可以实现为可重入，通常的原因如下：

+ 根据其性质，有些函数必须访问全局数据结构。malloc 函数库中的函数就是这方面的典范。这些函数为堆中的空闲块维护有一个全局链表。malloc 库函数的线程安全是通过使用互斥量来实现的。
+ 一些函数的接口本身就定义为不可重入，要么返回指针，指向由函数自身静态分配的存储空间，要么利用静态存储对该函数（或相关函数）历次调用间的信息加以维护。



#### 3.一次性初始化

多线程程序有时有这样的需求，不管创建了多少线程，有些初始化动作只能发生一次。

```c++
#include <pthread.h>

int pthread_once(pthread_once_t *once_control, void (*init)(void));
```

利用参数 once_control 的状态，函数 pthread_once()可以确保无论有多少线程对pthread_once()调用了多少次，也只会执行一次由init指向的调用者定义函数。

init 函数没有任何参数，形式如下：

```c++
void init(void)
{
  /* Function body */
}
```

另外，参数once_control 必须是一指针，指向初始化为PTHREAD_ONCE_INIT的静态变量。

```c++
pthread_once_t once_var = PTHREAD_ONCE_INIT;
```



#### 4.线程特有数据

实现函数线程安全最为有效的方式就是使其可重入，应以这种方式来实现所有新的函数库。不过，对于已有的不可重入函数库（可能问世于线程流行之前）来说，采用这种方法通常需要修改所有使用此类函数的应用程序。

使用线程特有数据技术是，可以无需修改函数接口而实现已有函数的线程安全。较之于可重入函数，采用线程特有数据的函数效率可能要略低一些，不过对于使用了这些调用的程序而言，则省去了修改程序之劳。

如印象笔记的图所示，线程特有数据使函数得以为每个调用线程分别维护一份变量的副本（copy）。线程特有数据是长期存在的。在同一线程对相同函数的历次调用间，每个线程的变量会持续存在，函数可以向每个调用线程返回各自的结果缓冲区（如果需要的话）。



#### 5.库函数视角下的线程特有数据

从技术层面考虑兼容线程特有数据的库函数如何实现：

+ 该函数必须为每个调用者线程分配单独的存储，且只需在线程初次调用此函数时分配一次即可；
+ 在同一线程对此函数的后续所有调用中，该函数都需要获取初次调用时线程分配的存储块地址。由于函数调用结束时会释放自动变量，故而函数不应利用自动变量存放存储快指针，也不能将指针存放于静态变量中，因为静态变量在进程中只有一个实例。Pthreads API 提供了函数来处理这一情况。
+ 不同（无相互依赖关系）函数各自可能都需要使用线程特有数据。每个函数都需要方法来标识其自身的线程特有数据（键），以便与其他函数所使用的线程特有数据有所区分。
+ 当线程提出时，函数无法控制将要发生的情况。这时，线程可能会执行该函数之外的代码。不过，一定存在某些机制（解构器），在线程退出时会自动释放为该线程所分配的存储。若非如此，随着持续不断地创建线程，调用函数和终止线程，将会引发内存泄露。



#### 6.线程特有数据 API 概述

要使用线程特有数据，库函数执行的一般步骤如下：

1. 函数创建一个键（key），用以将不同函数使用的线程特有数据项区分开来。调用函数pthread_key_create()可创建此“键”，且只需在首个调用该函数的线程中创建一次，函数pthread_once()的使用正是出于这一目的。键在创建时并未分配任何线程特有数据块。
2. 调用 pthread_key_create() 还有另一个目的，即允许调用者指定一个自定义解构函数，用于释放为该键所分配的各个存储块。当使用线程特有数据的线程终止时，Pthreads API 会自动调用此解构函数，同时将该线程的数据块指针作为参数传入。
3. 函数会为每个调用者线程特有数据块。这一分配通过调用malloc()（或类似函数）完成，每个线程只分配一次，且只会在线程初次调用此函数时分配。
4. 为了保存上一步所分配存储块的地址，函数会使用两个 Pthread 函数：pthread_setspecific() 和 pthread_getspecific()。调用函数 pthread_setspecific()实际上是对 Pthreads 实现发起这样的请求：保存该指针，并记录其与特定键（该函数的键）以及特定线程（调用者线程）的关联性。调用 pthread_getspecific()所执行的是互补操作：返回之前所保存的，与给定键以及调用线程相关联的指针。如果还没有指针与特定的键及线程相关联，那么pthread_getspecific()返回 NULL。函数可以利用这一点来判断自身是否是初次为某个线程所调用，若为初次，则必须为该线程分配空间。




#### 7.线程特有数据API详述

调用 pthread_key_create() 函数为线程特有数据创建一个新键，并通过key所指向的缓冲区返回给调用者。

因为进程中的所有线程都可使用返回的键，所以参数key应指向一个全局变量。

```c++
#include <pthread.h>

int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
```

函数 pthread_setspecific()要求 Pthreads API 将 value 的副本存储于一数据结构中，并将 value 与调用线程以及 key 相关联（key由之前对 pthread_key_create() 的调用返回）。pthread_getspecific()函数执行的操作与之相反，返回之前与本线程及给定key相关的值。

```c++
#include <pthread.h>

int pthread_setspecific(pthread_key_t key, const void *value);

void *pthread_getspecific(pthread_key_t key);
```



#### 8.线程局部存储

类似于线程特有数据，线程局部存储提供了持久的每线程存储。作为非标准特性，诸多其他的UNIX实现为其提供了相同，或类似的接口形式。

线程局部存储的主要优点在于，比线程特有数据的使用要简单。要创建线程局部变量，只需简单地在全局或静态变量的声明中包含 __thread说明符即可。

``static __thread buf[MAX_ERROR_LEN];``

但凡带有这种说明符的变量，每个线程都拥有一份对变量的拷贝。线程局部存储中的变量将一直存在，直至线程终止，届时会自动释放这一存储。

关于线程局部变量的声明和使用，需要注意如下几点。

+ 如果变量声明中使用了关键字 static 或 extern，那么关键字 __thread 必须紧随其后。
+ 与一般的全局或静态变量声明一样，线程局部变量在声明时可设置一个初始值。
+ 可以使用C语言取址操作符（&）来获取线程局部变量的地址。

例子：

```c++
#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <pthread.h>

#define MAX_ERROR_LEN 256

static __thread char buf[MAX_ERROR_LEN];

char * strerror(int err)
{
  if (err < 0 || err >= _sys_nerr || _sys_errlist[err] == NULL)
  {
    snprintf(buf, MAX_ERROR_LEN, "Unknown error %d", err);
  }
  else
  {
    strncpy(buf, _sys_errlist[err], MAX_ERROR_LEN - 1);
    buf[MAX_ERROR_LEN-1] = '\0';
  }
  
  return buf;
}
```

