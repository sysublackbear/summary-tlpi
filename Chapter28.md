### Chapter28.详述进程创建和程序执行

#### 1.进程记账

打开进程记账功能后，内核会在每个进程终止时将一条记账信息写入系统级的进程记账文件。这条账单记录包含了内核为该进程所维护的多种信息，包括终止状态以及进程消耗的CPU时间。



**打开和关闭进程记账功能**

特权进程可利用系统调用 acct()来打开和关闭进程记账功能。应用程序很少使用这一系统调用。一般会将相应命令置于系统启动脚本中，在系统每次重启时开启进程记账功能。

```c++
#define _BSD_SOURCE
#include <unistd.h>

int acct(const char * acctfile);
```

进程账单记录的定义在头文件<sys/acct.h>



#### 2.系统调用clone()

类似于fork()。clone()也能创建一个新进程。

但与fork()不同的是，克隆生成的子进程继续运行时不以调用处为起点，转而去调用以参数func所指定的函数，func又称为子函数。clone()对父子间的共享属性有更为精确的控制。clone()系统调用主要用于线程库的实现。



#### 3.fork()，vfork()，clone()之间的比较

结论：尽管vfork()要快于fork()，但较之于子进程随后调用exec()所耗费的时间，二者间的时间差异也就微不足道了。

fork()创建的子进程会从其父进程处继承（有时是共享）某些进程属性的副本，而对其他进程属性则不做继承。例如，子进程继承了父进程文件描述符表和信号处置的副本，但并不继承父进程的间隔定时器，记录锁或是挂起信号集合。相应地，进程执行exec()，某些进程属性保持不变，而会将其他属性重置为缺省值。例如：进程ID保持不变，文件描述符保持打开（除非设置了执行时关闭标志），间隔定时器得以保存，挂起信号依然挂起，不过会将对已处理信号的处置重置为默认设置，同时与共享内存段“脱钩”。